/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => AliasFromHeadingPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var AliasFromHeadingPlugin = class extends import_obsidian.Plugin {
  onload() {
    const { metadataCache, vault, workspace } = this.app;
    const headingByPath = new Map();
    function getHeading(file) {
      const { headings } = metadataCache.getFileCache(file);
      if (!Array.isArray(headings) || !headings.length) {
        return;
      }
      const { heading } = headings[0];
      return heading;
    }
    const clearHeadings = (0, import_obsidian.debounce)((path) => {
      if (!headingByPath.has(path)) {
        return;
      }
      const heading = headingByPath.get(path);
      headingByPath.clear();
      headingByPath.set(path, heading);
    }, 1e4, true);
    function loadFile(file) {
      if (!file) {
        return;
      }
      const { path } = file;
      const heading = getHeading(file);
      headingByPath.set(path, heading);
      clearHeadings(path);
    }
    workspace.onLayoutReady(() => {
      const activeFile = workspace.getActiveFile();
      loadFile(activeFile);
    });
    this.registerEvent(workspace.on("file-open", loadFile));
    this.registerEvent(vault.on("rename", (file, oldPath) => {
      if (!(file instanceof import_obsidian.TFile)) {
        return;
      }
      const { path } = file;
      const heading = headingByPath.get(oldPath);
      headingByPath.set(path, heading);
    }));
    this.registerEvent(metadataCache.on("changed", (file) => __async(this, null, function* () {
      const { path } = file;
      if (!headingByPath.has(path)) {
        return;
      }
      const prevHeading = headingByPath.get(path);
      const heading = getHeading(file);
      headingByPath.set(path, heading);
      if (prevHeading === heading) {
        return;
      }
      const modifiedFiles = Object.entries(metadataCache.resolvedLinks).reduce((paths, [toPath, links]) => {
        const hasRef = Object.keys(links).includes(path);
        return hasRef ? [...paths, toPath] : paths;
      }, []).map((p) => {
        const { links = [] } = metadataCache.getCache(p);
        const linksToReplace = links.map((rc) => rc.link).filter((link) => link.split("#")[0] === metadataCache.fileToLinktext(file, "")).map((link) => [prevHeading, heading].map((h) => `[[${link}|${h === void 0 ? link : h}]]`));
        return [p, linksToReplace];
      }).filter(([, linksToReplace]) => linksToReplace.length).map((_0) => __async(this, [_0], function* ([p, linksToReplace]) {
        const f = vault.getAbstractFileByPath(p);
        const prevContents = yield vault.read(f);
        const [contents, matches] = linksToReplace.reduce(([source, total], [find, replace]) => {
          let count = 0;
          const re = new RegExp(escapeRegExp(find), "g");
          const s = source.replace(re, () => {
            count++;
            return replace;
          });
          return [s, count + total];
        }, [prevContents, 0]);
        yield vault.modify(f, contents);
        return matches;
      }));
      const linkMatches = (yield Promise.all(modifiedFiles)).filter((m) => m);
      const fileCount = linkMatches.length;
      const linkCount = linkMatches.reduce((sum, value) => sum + value, 0);
      if (!fileCount || !linkCount) {
        return;
      }
      new import_obsidian.Notice(`Updated ${linkCount} ${pluralize(linkCount, "link")} in ${fileCount} ${pluralize(fileCount, "file")}.`);
    })));
    this.removeMetadataCachePatch = patch(metadataCache, {
      getLinkSuggestions(originalMethod) {
        return function() {
          const delimiter = "|";
          const suggestions = originalMethod();
          const frontmatterAliases = suggestions.filter((suggestion) => suggestion.hasOwnProperty("path") && suggestion.hasOwnProperty("alias")).map(({ path, alias }) => [path, alias].join(delimiter));
          const suggestionsFromHeading = vault.getMarkdownFiles().map((file) => {
            const alias = getHeading(file);
            const path = omitExtension(file.path);
            if (!alias || frontmatterAliases.includes([path, alias].join(delimiter))) {
              return;
            }
            return { file, path, alias };
          }).filter((v) => v);
          return [...suggestions, ...suggestionsFromHeading];
        };
      }
    });
  }
  onunload() {
    this.removeMetadataCachePatch();
  }
};
function escapeRegExp(source) {
  return source.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function omitExtension(path) {
  const i = path.lastIndexOf(".");
  return i === -1 || i === path.length - 1 || i === 0 ? path : path.slice(0, i);
}
function patch(source, methods) {
  const removals = Object.entries(methods).map(([key, createMethod]) => {
    const hadOwn = source.hasOwnProperty(key);
    const method = source[key];
    source[key] = createMethod(method.bind(source));
    return function remove() {
      if (hadOwn) {
        source[key] = method;
      } else {
        delete source[key];
      }
    };
  });
  return () => removals.forEach((r) => r());
}
function pluralize(count, singular, plural = `${singular}s`) {
  return count === 1 ? singular : plural;
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgZGVib3VuY2UsIE5vdGljZSwgUGx1Z2luLCBSZWZlcmVuY2VDYWNoZSwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbmludGVyZmFjZSBMaW5rU3VnZ2VzdGlvbiB7XG5cdGZpbGU6IFRGaWxlO1xuXHRwYXRoOiBzdHJpbmc7XG5cdGFsaWFzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGlhc0Zyb21IZWFkaW5nUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0cmVtb3ZlTWV0YWRhdGFDYWNoZVBhdGNoOiAoKSA9PiB2b2lkO1xuXG5cdG9ubG9hZCAoKSB7XG5cdFx0Y29uc3QgeyBtZXRhZGF0YUNhY2hlLCB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRjb25zdCBoZWFkaW5nQnlQYXRoID0gbmV3IE1hcCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0SGVhZGluZyAoZmlsZTpURmlsZSkge1xuXHRcdFx0Y29uc3QgeyBoZWFkaW5ncyB9ID0gbWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGluZ3MpIHx8ICFoZWFkaW5ncy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgeyBoZWFkaW5nIH0gPSBoZWFkaW5nc1swXTtcblx0XHRcdHJldHVybiBoZWFkaW5nO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgYSBmaWxlIG9wZW5zLCBjbGVhciBvdXQgdGhlIG9sZCBkYXRhIGFmdGVyXG5cdFx0Ly8gYSBkZWJvdW5jZWQgMTAgc2Vjb25kcy4gVGhpcyBnaXZlcyBwbGVudHkgb2YgdGltZSBmb3Jcblx0XHQvLyBhbnkgbGlua3MgdG8gYmUgdXBkYXRlZCwgaWYgdGhlIHVzZXIgdXBkYXRlcyB0aGUgaGVhZGluZ1xuXHRcdC8vIGFuZCBxdWlja2x5IG9wZW5zIGFub3RoZXIgZmlsZS5cblx0XHRjb25zdCBjbGVhckhlYWRpbmdzID0gZGVib3VuY2UoKHBhdGgpID0+IHtcblx0XHRcdGlmICghaGVhZGluZ0J5UGF0aC5oYXMocGF0aCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgaGVhZGluZyA9IGhlYWRpbmdCeVBhdGguZ2V0KHBhdGgpO1xuXHRcdFx0aGVhZGluZ0J5UGF0aC5jbGVhcigpO1xuXHRcdFx0aGVhZGluZ0J5UGF0aC5zZXQocGF0aCwgaGVhZGluZyk7XG5cdFx0fSwgMTAwMDAsIHRydWUpO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZEZpbGUgKGZpbGU6VEZpbGUpIHtcblx0XHRcdGlmICghZmlsZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB7IHBhdGggfSA9IGZpbGU7XG5cdFx0XHRjb25zdCBoZWFkaW5nID0gZ2V0SGVhZGluZyhmaWxlKTtcblx0XHRcdGhlYWRpbmdCeVBhdGguc2V0KHBhdGgsIGhlYWRpbmcpO1xuXHRcdFx0Y2xlYXJIZWFkaW5ncyhwYXRoKTtcblx0XHR9XG5cblx0XHR3b3Jrc3BhY2Uub25MYXlvdXRSZWFkeSgoKSA9PiB7XG5cdFx0XHRjb25zdCBhY3RpdmVGaWxlID0gd29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcblx0XHRcdGxvYWRGaWxlKGFjdGl2ZUZpbGUpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KHdvcmtzcGFjZS5vbignZmlsZS1vcGVuJywgbG9hZEZpbGUpKTtcblxuXHRcdHRoaXMucmVnaXN0ZXJFdmVudCh2YXVsdC5vbigncmVuYW1lJywgKGZpbGUsIG9sZFBhdGgpID0+IHtcblx0XHRcdGlmICghKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgeyBwYXRoIH0gPSBmaWxlO1xuXHRcdFx0Y29uc3QgaGVhZGluZyA9IGhlYWRpbmdCeVBhdGguZ2V0KG9sZFBhdGgpO1xuXHRcdFx0aGVhZGluZ0J5UGF0aC5zZXQocGF0aCwgaGVhZGluZyk7XG5cdFx0fSkpO1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KG1ldGFkYXRhQ2FjaGUub24oJ2NoYW5nZWQnLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0Y29uc3QgeyBwYXRoIH0gPSBmaWxlO1xuXG5cdFx0XHRpZiAoIWhlYWRpbmdCeVBhdGguaGFzKHBhdGgpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcHJldkhlYWRpbmcgPSBoZWFkaW5nQnlQYXRoLmdldChwYXRoKTtcblx0XHRcdGNvbnN0IGhlYWRpbmcgPSBnZXRIZWFkaW5nKGZpbGUpO1xuXHRcdFx0aGVhZGluZ0J5UGF0aC5zZXQocGF0aCwgaGVhZGluZyk7XG5cblx0XHRcdGlmIChwcmV2SGVhZGluZyA9PT0gaGVhZGluZykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1vZGlmaWVkRmlsZXMgPSBPYmplY3QuZW50cmllcyhtZXRhZGF0YUNhY2hlLnJlc29sdmVkTGlua3MpXG5cdFx0XHRcdC5yZWR1Y2UoKHBhdGhzLCBbdG9QYXRoLCBsaW5rc10pID0+IHtcblx0XHRcdFx0XHRjb25zdCBoYXNSZWYgPSBPYmplY3Qua2V5cyhsaW5rcykuaW5jbHVkZXMocGF0aCk7XG5cdFx0XHRcdFx0cmV0dXJuIGhhc1JlZiA/IFsuLi5wYXRocywgdG9QYXRoXSA6IHBhdGhzO1xuXHRcdFx0XHR9LCBbXSlcblx0XHRcdFx0Lm1hcCgocDpzdHJpbmcpID0+IHtcblx0XHRcdFx0XHRjb25zdCB7IGxpbmtzID0gW10gfSA9IG1ldGFkYXRhQ2FjaGUuZ2V0Q2FjaGUocCk7XG5cdFx0XHRcdFx0Y29uc3QgbGlua3NUb1JlcGxhY2UgPSBsaW5rc1xuXHRcdFx0XHRcdFx0Lm1hcCgocmM6UmVmZXJlbmNlQ2FjaGUpID0+IHJjLmxpbmspXG5cdFx0XHRcdFx0XHQuZmlsdGVyKChsaW5rKSA9PiBsaW5rLnNwbGl0KCcjJylbMF0gPT09IG1ldGFkYXRhQ2FjaGUuZmlsZVRvTGlua3RleHQoZmlsZSwgJycpKVxuXHRcdFx0XHRcdFx0Ly8gTWFrZSBwYWlycyBvZiBsaW5rcyB0byBiZSBmb3VuZCBhbmQgcmVwbGFjZWQuXG5cdFx0XHRcdFx0XHQvLyBTb21lIG9mIHRoZXNlIHBhaXJzIG1heSBiZSByZWR1bmRhbnQgb3IgcmVzdWx0IGluIG5vIG1hdGNoZXNcblx0XHRcdFx0XHRcdC8vIGZvciBhbnkgZ2l2ZW4gcGF0aCwgYnV0IHRoYXQncyBva2F5LlxuXHRcdFx0XHRcdFx0Ly8gVGhlIGByYy5vcmlnaW5hbGAgYW5kIGByYy5kaXNwbGF5VGV4dGAgdmFsdWVzIGFyZSBub3QgdXNlZCxcblx0XHRcdFx0XHRcdC8vIGJlY2F1c2UgaXQgY291bGQgYmUgaW5hY2N1cmF0ZSBpZiB0aGUgaGVhZGluZyBlbmRzIHdpdGggYSBgXWAuXG5cdFx0XHRcdFx0XHQvLyBUaGUgT2JzaWRpYW4gYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgbGlua3MgaXMgY29ycmVjdCxcblx0XHRcdFx0XHRcdC8vIGJ1dCB0aGlzIGV4dHJhIHdvcmsgaXMgbmVlZGVkIHRvIG1hdGNoIHRvIHRoZSB1c2VyIGludGVudC5cblx0XHRcdFx0XHRcdC5tYXAoKGxpbmspID0+XG5cdFx0XHRcdFx0XHRcdFtwcmV2SGVhZGluZywgaGVhZGluZ11cblx0XHRcdFx0XHRcdFx0XHQubWFwKChoKSA9PiBgW1ske2xpbmt9fCR7aCA9PT0gdW5kZWZpbmVkID8gbGluayA6IGh9XV1gKVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdHJldHVybiBbcCwgbGlua3NUb1JlcGxhY2VdO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZmlsdGVyKChbLCBsaW5rc1RvUmVwbGFjZV06W3N0cmluZywgW11dKSA9PiBsaW5rc1RvUmVwbGFjZS5sZW5ndGgpXG5cdFx0XHRcdC5tYXAoYXN5bmMgKFtwLCBsaW5rc1RvUmVwbGFjZV06W3N0cmluZywgW11dKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZiA9IDxURmlsZT52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocCk7XG5cdFx0XHRcdFx0Y29uc3QgcHJldkNvbnRlbnRzID0gYXdhaXQgdmF1bHQucmVhZChmKTtcblx0XHRcdFx0XHRjb25zdCBbY29udGVudHMsIG1hdGNoZXNdOihzdHJpbmcgfCBudW1iZXIpW10gPSBsaW5rc1RvUmVwbGFjZS5yZWR1Y2UoXG5cdFx0XHRcdFx0XHQoW3NvdXJjZSwgdG90YWxdOltzdHJpbmcsIG51bWJlcl0sIFtmaW5kLCByZXBsYWNlXTpzdHJpbmdbXSkgPT4ge1xuXHRcdFx0XHRcdFx0XHQvLyBUaGUgaGVhZGluZyBtdXN0IGJlIGEgcmVndWxhciBleHByZXNzaW9uIGFuZCBub3QgYSBzdHJpbmcuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgc29sdmVzIHR3byBwcm9ibGVtcyB3aXRoIHRoZSB1c2Ugb2YgYFN0cmluZy5yZXBsYWNlKClgLlxuXHRcdFx0XHRcdFx0XHQvLyAxLiBUaGlzIGFsbG93cyByZXBsYWNlbWVudCBwYXR0ZXJucyAoYCQkLCBgJCZgLCBldGMuKVxuXHRcdFx0XHRcdFx0XHQvLyAgICB0byBiZSBpbmNsdWRlZCBpbiB0aGUgaGVhZGluZyB3aXRob3V0IGNhdXNpbmcgbWlzbWF0Y2hlcyxcblx0XHRcdFx0XHRcdFx0Ly8gICAgc2ltaWxhciB0byB0aGUgYWZvcmVtZW50aW9uZWQgYF1gIHByb2JsZW0uXG5cdFx0XHRcdFx0XHRcdC8vIDIuIFRoaXMgYWxsb3dzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGJlIGEgZnVuY3Rpb24sXG5cdFx0XHRcdFx0XHRcdC8vICAgIHNvIHRoZSBudW1iZXIgb2YgbWF0Y2hlcyBjYW4gYmUgY291bnRlZCBhcyBhIHNpZGUgZWZmZWN0LlxuXHRcdFx0XHRcdFx0XHRsZXQgY291bnQgPSAwO1xuXHRcdFx0XHRcdFx0XHRjb25zdCByZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGZpbmQpLCAnZycpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzID0gc291cmNlLnJlcGxhY2UocmUsICgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXBsYWNlO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFtzLCBjb3VudCArIHRvdGFsXTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRbcHJldkNvbnRlbnRzLCAwXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YXdhaXQgdmF1bHQubW9kaWZ5KGYsIDxzdHJpbmc+Y29udGVudHMpO1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgbGlua01hdGNoZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwobW9kaWZpZWRGaWxlcykpXG5cdFx0XHRcdC5maWx0ZXIoKG0pID0+IG0pO1xuXHRcdFx0Y29uc3QgZmlsZUNvdW50ID0gbGlua01hdGNoZXMubGVuZ3RoO1xuXHRcdFx0Y29uc3QgbGlua0NvdW50ID0gbGlua01hdGNoZXNcblx0XHRcdFx0LnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApO1xuXG5cdFx0XHRpZiAoIWZpbGVDb3VudCB8fCAhbGlua0NvdW50KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bmV3IE5vdGljZShgVXBkYXRlZCAke2xpbmtDb3VudH0gJHtwbHVyYWxpemUobGlua0NvdW50LCAnbGluaycpfSBpbiAke2ZpbGVDb3VudH0gJHtwbHVyYWxpemUoZmlsZUNvdW50LCAnZmlsZScpfS5gKTtcblx0XHR9KSk7XG5cblx0XHQvLyBFeHRlbmQgdGhlIGBnZXRMaW5rU3VnZ2VzdGlvbnNgIG1ldGhvZCB0byBpbmNsdWRlIGFsaWFzZXNcblx0XHQvLyBkZXJpdmVkIGZyb20gaGVhZGluZ3MuXG5cdFx0dGhpcy5yZW1vdmVNZXRhZGF0YUNhY2hlUGF0Y2ggPSBwYXRjaChtZXRhZGF0YUNhY2hlLCB7XG5cdFx0XHRnZXRMaW5rU3VnZ2VzdGlvbnMgKG9yaWdpbmFsTWV0aG9kOiAoKSA9PiBMaW5rU3VnZ2VzdGlvbltdKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGVsaW1pdGVyID0gJ3wnO1xuXHRcdFx0XHRcdGNvbnN0IHN1Z2dlc3Rpb25zID0gb3JpZ2luYWxNZXRob2QoKTtcblx0XHRcdFx0XHRjb25zdCBmcm9udG1hdHRlckFsaWFzZXMgPSBzdWdnZXN0aW9uc1xuXHRcdFx0XHRcdFx0LmZpbHRlcigoc3VnZ2VzdGlvbikgPT4gc3VnZ2VzdGlvbi5oYXNPd25Qcm9wZXJ0eSgncGF0aCcpICYmIHN1Z2dlc3Rpb24uaGFzT3duUHJvcGVydHkoJ2FsaWFzJykpXG5cdFx0XHRcdFx0XHQubWFwKCh7IHBhdGgsIGFsaWFzIH0pID0+IFtwYXRoLCBhbGlhc10uam9pbihkZWxpbWl0ZXIpKTtcblx0XHRcdFx0XHRjb25zdCBzdWdnZXN0aW9uc0Zyb21IZWFkaW5nID0gdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpXG5cdFx0XHRcdFx0XHQubWFwKChmaWxlKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGFsaWFzID0gZ2V0SGVhZGluZyhmaWxlKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcGF0aCA9IG9taXRFeHRlbnNpb24oZmlsZS5wYXRoKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFhbGlhcyB8fCBmcm9udG1hdHRlckFsaWFzZXMuaW5jbHVkZXMoW3BhdGgsIGFsaWFzXS5qb2luKGRlbGltaXRlcikpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7IGZpbGUsIHBhdGgsIGFsaWFzIH07XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmZpbHRlcigodikgPT4gdik7XG5cdFx0XHRcdFx0cmV0dXJuIFsuLi5zdWdnZXN0aW9ucywgLi4uc3VnZ2VzdGlvbnNGcm9tSGVhZGluZ107XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdG9udW5sb2FkICgpIHtcblx0XHR0aGlzLnJlbW92ZU1ldGFkYXRhQ2FjaGVQYXRjaCgpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCAoc291cmNlOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIHNvdXJjZS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBvbWl0RXh0ZW5zaW9uIChwYXRoOiBzdHJpbmcpIHtcblx0Y29uc3QgaSA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcblx0cmV0dXJuIC0xID09PSBpIHx8IGkgPT09IHBhdGgubGVuZ3RoIC0gMSB8fCAwID09PSBpID8gcGF0aCA6IHBhdGguc2xpY2UoMCwgaSk7XG59XG5cbi8vIEluc3BpcmVkIGJ5OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BqZWJ5L21vbmtleS1hcm91bmRcbmZ1bmN0aW9uIHBhdGNoIChzb3VyY2U6YW55LCBtZXRob2RzOmFueSkge1xuXHRjb25zdCByZW1vdmFscyA9IE9iamVjdC5lbnRyaWVzKG1ldGhvZHMpLm1hcCgoW2tleSwgY3JlYXRlTWV0aG9kXSkgPT4ge1xuXHRcdGNvbnN0IGhhZE93biA9IHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuXHRcdGNvbnN0IG1ldGhvZCA9IHNvdXJjZVtrZXldO1xuXHRcdHNvdXJjZVtrZXldID0gY3JlYXRlTWV0aG9kKG1ldGhvZC5iaW5kKHNvdXJjZSkpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG5cdFx0XHRpZiAoaGFkT3duKSB7XG5cdFx0XHRcdHNvdXJjZVtrZXldID0gbWV0aG9kO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIHNvdXJjZVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSlcblx0cmV0dXJuICgpID0+IHJlbW92YWxzLmZvckVhY2goKHIpID0+IHIoKSlcbn1cblxuZnVuY3Rpb24gcGx1cmFsaXplIChjb3VudDpudW1iZXIsIHNpbmd1bGFyOnN0cmluZywgcGx1cmFsID0gYCR7c2luZ3VsYXJ9c2ApOnN0cmluZyB7XG5cdHJldHVybiBjb3VudCA9PT0gMSA/IHNpbmd1bGFyIDogcGx1cmFsO1xufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBZ0U7QUFRaEUsMkNBQW9ELHVCQUFPO0FBQUEsRUFHMUQsU0FBVTtBQUNULFVBQU0sRUFBRSxlQUFlLE9BQU8sY0FBYyxLQUFLO0FBQ2pELFVBQU0sZ0JBQWdCLElBQUk7QUFFMUIsd0JBQXFCLE1BQVk7QUFDaEMsWUFBTSxFQUFFLGFBQWEsY0FBYyxhQUFhO0FBQ2hELFVBQUksQ0FBQyxNQUFNLFFBQVEsYUFBYSxDQUFDLFNBQVMsUUFBUTtBQUNqRDtBQUFBO0FBRUQsWUFBTSxFQUFFLFlBQVksU0FBUztBQUM3QixhQUFPO0FBQUE7QUFPUixVQUFNLGdCQUFnQiw4QkFBUyxDQUFDLFNBQVM7QUFDeEMsVUFBSSxDQUFDLGNBQWMsSUFBSSxPQUFPO0FBQzdCO0FBQUE7QUFFRCxZQUFNLFVBQVUsY0FBYyxJQUFJO0FBQ2xDLG9CQUFjO0FBQ2Qsb0JBQWMsSUFBSSxNQUFNO0FBQUEsT0FDdEIsS0FBTztBQUVWLHNCQUFtQixNQUFZO0FBQzlCLFVBQUksQ0FBQyxNQUFNO0FBQ1Y7QUFBQTtBQUVELFlBQU0sRUFBRSxTQUFTO0FBQ2pCLFlBQU0sVUFBVSxXQUFXO0FBQzNCLG9CQUFjLElBQUksTUFBTTtBQUN4QixvQkFBYztBQUFBO0FBR2YsY0FBVSxjQUFjLE1BQU07QUFDN0IsWUFBTSxhQUFhLFVBQVU7QUFDN0IsZUFBUztBQUFBO0FBR1YsU0FBSyxjQUFjLFVBQVUsR0FBRyxhQUFhO0FBRTdDLFNBQUssY0FBYyxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQU0sWUFBWTtBQUN4RCxVQUFJLENB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
